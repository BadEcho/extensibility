<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ExtensibilityConfigurationDirectoryNotFound" xml:space="preserve">
    <value>A plugin directory was explicitly specified in this application's configuration, however '{0}' does not exist. Please ensure that a desired plugin directory exists when configuring its use, or simply forego specifying an explicit plugin directory name if its existence cannot be guaranteed.</value>
  </data>
  <data name="ExtensibilityPointMissingDependency" xml:space="preserve">
    <value>Cannot check if assembly '{0}' is an extensibility point because it is missing the following dependency: '{1}'</value>
  </data>
  <data name="HostAdapterUnregisteredMethod" xml:space="preserve">
    <value>No routable plugin has been registered to handle calls made to '{0}'.</value>
  </data>
  <data name="IncompatibleDependencyTypeForInjection" xml:space="preserve">
    <value>Injection of exported parts into an attributed pluggable part of type '{0}' within a self-armed context requires said part to be assignable to the specified dependency value of type '{1}'.</value>
  </data>
  <data name="MultipleExportsFoundForFamily" xml:space="preserve">
    <value>Multiple exports for contract type '{0}' belong to the '{1}' filterable family; any part beyond the first of its type from a filterable context is ignored.</value>
  </data>
  <data name="MultipleExportsFoundForLocalContract" xml:space="preserve">
    <value>Multiple exports for the locally exported contract type '{0}' were found. Only a single provider should ever be available for contract types meant to be loaded from a local context.</value>
  </data>
  <data name="NoContractInConfiguration" xml:space="preserve">
    <value>Extensibility configuration lacks registration for contract '{0}'.</value>
  </data>
  <data name="NoDependencyArmed" xml:space="preserve">
    <value>Registry was not armed with an expected dependency.</value>
  </data>
  <data name="NoExportFoundForFamily" xml:space="preserve">
    <value>No export for contract type '{0}' belongs to the '{1}' filterable family.</value>
  </data>
  <data name="NoExportFoundForLocalContract" xml:space="preserve">
    <value>No local export for the contract type '{0}' was found. If this is an expected contract, then it should be exported within the consuming component's own assembly. If expectancy is tenuous, check for support via the appropriate methods provided by the plugin host system first.</value>
  </data>
  <data name="ProcessCannotExportContracts" xml:space="preserve">
    <value>The executing process is unmanaged; therefore, no contract implementation is able to be exported by it.</value>
  </data>
  <data name="RoutablePluginIdNotValid" xml:space="preserve">
    <value>'{0}' is not a valid call-routable plugin identity value. Values must be parseable as standard globally unique identifiers.</value>
  </data>
  <data name="RoutableProxyNotInitializedCorrectly" xml:space="preserve">
    <value>RoutableProxy was not provided a IHostAdapter due to improper initialization. Use a static factory method such as RoutableProxy.Create instead to initialize the proxy properly.</value>
  </data>
  <data name="RoutableProxyNullMethodInfo" xml:space="preserve">
    <value>RouteProxy instance was somehow invoked with null method information.</value>
  </data>
  <data name="PluginBadImageException" xml:space="preserve">
    <value>The file '{0}' being scanned for pluggable exports failed to load due to most likely not being a valid .NET assembly.</value>
  </data>
  <data name="PluginFileLoadException" xml:space="preserve">
    <value>The file '{0}' being scanned for pluggable exports failed to load.</value>
  </data>
  <data name="FamilyIdNotRegistered" xml:space="preserve">
    <value>'{0}' is not a registered filterable family identity value. Registration of a filterable family requires a FilterableFamily export action.</value>
  </data>
  <data name="FamilyIdNotValid" xml:space="preserve">
    <value>'{0}' is not a valid filterable family identity value. Values must be parseable as standard globally unique identifiers.</value>
  </data>
</root>